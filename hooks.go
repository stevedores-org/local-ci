package main

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"
)

// getPreCommitHookTemplate generates a project-aware pre-commit hook
func getPreCommitHookTemplate(root string) string {
	projectType := DetectProjectType(root)
	stagesCmd := "fmt"

	// Determine appropriate fast-check stages based on project type
	switch projectType {
	case ProjectTypeRust:
		stagesCmd = "fmt clippy"
	case ProjectTypePython:
		stagesCmd = "format lint"
	case ProjectTypeGo:
		stagesCmd = "fmt vet"
	case ProjectTypeNode:
		stagesCmd = "lint"
	case ProjectTypeJava:
		stagesCmd = "build"
	default:
		stagesCmd = "fmt"
	}

	return `#!/bin/bash
# local-ci pre-commit hook
# Auto-generated by local-ci init
# Runs local-ci before allowing commits

set -e

# Run local-ci with fast checks
if ! local-ci ` + stagesCmd + `; then
  echo ""
  echo "‚ùå Pre-commit checks failed. Fix the issues above and try again."
  echo ""
  echo "üí° Tip: Run 'local-ci --fix' to auto-fix formatting issues."
  exit 1
fi

echo "‚úÖ Pre-commit checks passed"
`
}

// CreatePreCommitHook creates or updates the pre-commit hook
func CreatePreCommitHook(root string) error {
	gitDir := filepath.Join(root, ".git")
	hooksDir := filepath.Join(gitDir, "hooks")

	// Create hooks directory if it doesn't exist
	if err := os.MkdirAll(hooksDir, 0755); err != nil {
		return fmt.Errorf("failed to create hooks directory: %w", err)
	}

	preCommitPath := filepath.Join(hooksDir, "pre-commit")

	// Check if hook already exists
	existingContent := ""
	if data, err := os.ReadFile(preCommitPath); err == nil {
		existingContent = string(data)
	}

	// If hook already exists and contains local-ci, skip
	if strings.Contains(existingContent, "local-ci") {
		return nil // Already has local-ci hook
	}

	// Write new hook or update existing
	preCommitHookTemplate := getPreCommitHookTemplate(root)
	content := preCommitHookTemplate
	if existingContent != "" && !strings.HasPrefix(existingContent, "#!/bin/bash") {
		// Append to existing hook if it doesn't already have shebang
		content = existingContent + "\n" + preCommitHookTemplate
	}

	// Write hook file
	if err := os.WriteFile(preCommitPath, []byte(content), 0755); err != nil {
		return fmt.Errorf("failed to write pre-commit hook: %w", err)
	}

	return nil
}

// RemovePreCommitHook removes the pre-commit hook
func RemovePreCommitHook(root string) error {
	preCommitPath := filepath.Join(root, ".git", "hooks", "pre-commit")

	data, err := os.ReadFile(preCommitPath)
	if err != nil {
		if os.IsNotExist(err) {
			return nil // Hook doesn't exist, nothing to remove
		}
		return fmt.Errorf("failed to read pre-commit hook: %w", err)
	}

	content := string(data)

	// If hook only contains local-ci, remove the file
	if strings.Contains(content, "local-ci pre-commit hook") && !strings.Contains(content, "local-ci") {
		return os.Remove(preCommitPath)
	}

	// Otherwise, remove local-ci section
	lines := strings.Split(content, "\n")
	var filtered []string
	skip := false
	for _, line := range lines {
		if strings.Contains(line, "local-ci pre-commit hook") {
			skip = true
		}
		if skip && strings.HasPrefix(line, "#!/bin/bash") && line != lines[0] {
			// End of local-ci section
			skip = false
			continue
		}
		if !skip {
			filtered = append(filtered, line)
		}
	}

	// Write back
	newContent := strings.TrimSpace(strings.Join(filtered, "\n"))
	if newContent == "" {
		return os.Remove(preCommitPath)
	}

	return os.WriteFile(preCommitPath, []byte(newContent+"\n"), 0755)
}
